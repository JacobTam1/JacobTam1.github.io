<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Org Chart</title>
  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; display: flex; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #fafafa; }

    #sidebar {
      width: 200px;
      background: #fff;
      border-right: 1px solid #ccc;
      padding: 12px;
      box-sizing: border-box;
    }
    #sidebar h3 { margin: 0 0 10px; font-size: 16px; }
    #sidebar ul { list-style: none; padding: 0; margin: 0; }
    #sidebar li {
      padding: 6px 10px;
      margin-bottom: 4px;
      cursor: pointer;
      border-radius: 4px;
    }
    #sidebar li.selected {
      background: #950038;
      color: #fff;
    }

    svg { flex: 1; overflow: visible; }

    .link { fill: none; stroke: #999; stroke-width: 1.5px; }
    .link.highlight { stroke: #950038; stroke-width: 2.5px; }

    .node rect {
      fill: #fff;
      stroke: #ccc;
      stroke-width: 1.5px;
      rx: 5px;
      ry: 5px;
    }
    .node.selected rect { stroke: #950038; stroke-width: 2.5px; }

    .node-name {
      font: 14px "PPNeueMontreal-Medium v2.4", sans-serif;
      font-weight: 600;
      fill: #950038;
      text-anchor: middle;
    }
    .node-title {
      font: 12px sans-serif;
      fill: #666;
      text-align: center;
      dominant-baseline: hanging;
      width: 180px;
    }
    .node-count { font: 10px sans-serif; fill: #666; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Departments</h3>
    <ul id="deptList"></ul>
  </div>

  <svg id="orgChart"></svg>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  const nodeW = 180, nodeH = 110, img = 40;
  const vGap  = 100, hGap  = 0;
  const sidebarWidth = 200;

  const svg   = d3.select("#orgChart"),
        gMain = svg.append("g").attr("class","chart"),
        gLinks= gMain.append("g").attr("class","links"),
        gNodes= gMain.append("g").attr("class","nodes");

  const zoom  = d3.zoom().scaleExtent([.5,2]).on("zoom", e=>gMain.attr("transform",e.transform));
  svg.call(zoom);

  let rawData, curRoot, selectedNode=null;
  const tree = d3.tree().nodeSize([nodeW+hGap, nodeH+vGap]).separation((a,b)=>(a.parent===b.parent?1.2:1.8));

  function collapseToLevel(node, level, current = 0) {
    if (current >= level && node.children) {
      node._children = node.children;
      node._children.forEach(child => collapseToLevel(child, level, current + 1));
      node.children = null;
    } else if (node.children) {
      node.children.forEach(child => collapseToLevel(child, level, current + 1));
    }
  }

  function buildHierarchy(data, dept){
    const rows = (dept && dept !== "All") ? data.filter(d => d.Department === dept) : data;
    const byId = new Map();
    rows.forEach(r => byId.set(r.PersonID, { ...r, children: [] }));
    const roots = [];
    rows.forEach(r => {
      const node = byId.get(r.PersonID);
      if (!r.SupervisorID || !byId.has(r.SupervisorID)) roots.push(node);
      else byId.get(r.SupervisorID).children.push(node);
    });
    if (roots.length === 1) return d3.hierarchy(roots[0]);
    const dummy = { _dummy: true, children: roots };
    return d3.hierarchy(dummy);
  }

  function render(root){
    curRoot = root;
    tree(root);
    const allNodes = root.descendants();
    const nodes = allNodes.filter(d => !d.data._dummy);
    const links = root.links().filter(l => !l.source.data._dummy && !l.target.data._dummy);

    const linkSel = gLinks.selectAll("path.link").data(links, d => d.target.data.PersonID);
    linkSel.exit().remove();
    linkSel.enter().append("path").attr("class","link")
      .merge(linkSel)
      .attr("d", d => `M${d.source.x},${d.source.y}V${d.target.y}H${d.target.x}`)
      .attr("class", d => isHighlighted(d) ? "link highlight" : "link");

    const nodeSel = gNodes.selectAll("g.node").data(nodes, d => d.data.PersonID);
    nodeSel.exit().remove();

    const nodeEnter = nodeSel.enter().append("g")
      .attr("class", "node")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .on("click", (ev, d) => {
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else if (d._children) {
          d.children = d._children;
          d._children = null;
        }
        selectedNode = d;
        render(root);
      });

    nodeEnter.append("rect")
      .attr("x", -nodeW/2).attr("y", -nodeH/2)
      .attr("width", nodeW).attr("height", nodeH);

    nodeEnter.append("svg:image")
      .attr("x", -img/2).attr("y", -nodeH/2 + 10)
      .attr("width", img).attr("height", img)
      .attr("href", d => d.data.Photo || "");

    nodeEnter.append("text")
      .attr("class", "node-name")
      .attr("dy", -nodeH/2 + 10 + img + 15)
      .text(d => d.data.Name);

    nodeEnter.append("foreignObject")
      .attr("x", -nodeW/2).attr("y", -nodeH/2 + 10 + img + 20)
      .attr("width", nodeW).attr("height", 40)
      .append("xhtml:div")
      .attr("class", "node-title")
      .style("width", nodeW + "px")
      .style("word-wrap", "break-word")
      .style("overflow", "hidden")
      .style("text-overflow", "ellipsis")
      .style("white-space", "nowrap")
      .text(d => {
        const t = d.data["Job Title"] || "";
        return t.length > 50 ? t.slice(0, 47) + "…" : t;
      });

    nodeEnter.filter(d => d.children?.length || d._children?.length)
      .append("text")
      .attr("class", "node-count")
      .attr("text-anchor", "end")
      .attr("x", nodeW/2 - 4).attr("y", nodeH/2 - 4)
      .text(d => {
        const c = d.children ? d.children.length : d._children?.length || 0;
        const sym = d._children ? "▶" : "▼";
        return c ? `${c} ${sym}` : "";
      });

    const nodeMerge = nodeEnter.merge(nodeSel);
    nodeMerge.attr("transform", d => `translate(${d.x},${d.y})`)
             .classed("selected", d => selectedNode && d === selectedNode)
             .select(".node-count")
             .text(d => {
               if (!d.children && !d._children) return "";
               const c = d.children ? d.children.length : d._children.length;
               const sym = d._children ? "▶" : "▼";
               return `${c} ${sym}`;
             });

    const [xMin, xMax] = d3.extent(nodes, d => d.x);
    const [yMin, yMax] = d3.extent(nodes, d => d.y);
    const viewW = xMax - xMin + nodeW * 2;
    const viewH = yMax - yMin + nodeH * 2;
    const containerW = svg.node().clientWidth;
    const offsetX = (containerW - sidebarWidth - viewW) / 2 + sidebarWidth - xMin;
    const offsetY = 120;
    svg.transition().duration(600).call(zoom.transform, d3.zoomIdentity.translate(offsetX, offsetY));
  }

  function isHighlighted(link){
    if (!selectedNode) return false;
    let cur = selectedNode;
    while (cur.parent) {
      if (cur.parent === link.source && cur === link.target) return true;
      cur = cur.parent;
    }
    return false;
  }

  function populateSidebar(data){
    const depts = Array.from(new Set(data.map(d => d.Department))).sort();
    depts.unshift("All");
    const list = d3.select("#deptList");
    list.selectAll("li")
        .data(depts)
        .enter().append("li")
          .text(d => d)
          .classed("selected", d => d === "All")
          .on("click", (ev, dept) => {
            list.selectAll("li").classed("selected", d => d === dept);
            selectedNode = null;
            const root = buildHierarchy(rawData, dept);
            collapseToLevel(root, 1);
            render(root);
          });
  }

  d3.csv("general_bamboohr_org_chart.csv").then(data => {
    data.forEach(d => {
      d.SupervisorID = (!d.SupervisorID || d.SupervisorID.trim() === "" || d.SupervisorID === "NULL") ? null : d.SupervisorID;
      if (d.Name) d.Name = d.Name.replace(/\r|\n/g, " ").trim();
      if (d["Job Title"]) d["Job Title"] = d["Job Title"].replace(/\r|\n/g, " ").trim();
    });
    rawData = data;
    populateSidebar(data);
    const root = buildHierarchy(data);
    collapseToLevel(root, 1);
    render(root);
  }).catch(err => console.error(err));
  </script>
</body>
</html>
